// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package monitor_db

import (
	"context"
	"database/sql"
)

const addClient = `-- name: AddClient :exec
insert into clients(clientId) values(?) on conflict do nothing
`

func (q *Queries) AddClient(ctx context.Context, clientid int64) error {
	_, err := q.db.ExecContext(ctx, addClient, clientid)
	return err
}

const addSubscription = `-- name: AddSubscription :exec
insert into user_url_subscription (clientId, urlId) values (?, ?)
`

type AddSubscriptionParams struct {
	Clientid sql.NullInt64
	Urlid    sql.NullInt64
}

func (q *Queries) AddSubscription(ctx context.Context, arg AddSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, addSubscription, arg.Clientid, arg.Urlid)
	return err
}

const addUrlToTrack = `-- name: AddUrlToTrack :one
insert into urls_to_request(url) values (?) returning id
`

func (q *Queries) AddUrlToTrack(ctx context.Context, url string) (int64, error) {
	row := q.db.QueryRowContext(ctx, addUrlToTrack, url)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getEndpointsToMonitor = `-- name: GetEndpointsToMonitor :many
select id, url from urls_to_request
`

func (q *Queries) GetEndpointsToMonitor(ctx context.Context) ([]UrlsToRequest, error) {
	rows, err := q.db.QueryContext(ctx, getEndpointsToMonitor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UrlsToRequest
	for rows.Next() {
		var i UrlsToRequest
		if err := rows.Scan(&i.ID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUrlIdToTrack = `-- name: GetUrlIdToTrack :one
select id from urls_to_request where url = ?
`

func (q *Queries) GetUrlIdToTrack(ctx context.Context, url string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUrlIdToTrack, url)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserMonitoredEndpoints = `-- name: GetUserMonitoredEndpoints :many
select ur.url
from urls_to_request ur
inner join user_url_subscription uus on ur.id = uus.urlId
inner join clients c on uus.clientId = c.clientId
where c.clientId = ?
`

func (q *Queries) GetUserMonitoredEndpoints(ctx context.Context, clientid int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserMonitoredEndpoints, clientid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var url string
		if err := rows.Scan(&url); err != nil {
			return nil, err
		}
		items = append(items, url)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersToNotify = `-- name: GetUsersToNotify :many
select c.clientId
from clients c
inner join user_url_subscription uus on c.clientId = uus.clientId
inner join urls_to_request ur on uus.urlId = ur.id
where ur.url = ?
`

func (q *Queries) GetUsersToNotify(ctx context.Context, url string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getUsersToNotify, url)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var clientid int64
		if err := rows.Scan(&clientid); err != nil {
			return nil, err
		}
		items = append(items, clientid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeClient = `-- name: RemoveClient :exec
delete from clients where clientId = ?
`

func (q *Queries) RemoveClient(ctx context.Context, clientid int64) error {
	_, err := q.db.ExecContext(ctx, removeClient, clientid)
	return err
}

const removeSubscription = `-- name: RemoveSubscription :exec
delete from user_url_subscription where clientId = ? and urlId = ?
`

type RemoveSubscriptionParams struct {
	Clientid sql.NullInt64
	Urlid    sql.NullInt64
}

func (q *Queries) RemoveSubscription(ctx context.Context, arg RemoveSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, removeSubscription, arg.Clientid, arg.Urlid)
	return err
}

const removeUrlToTrack = `-- name: RemoveUrlToTrack :exec
delete from urls_to_request where url = ?
`

func (q *Queries) RemoveUrlToTrack(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, removeUrlToTrack, url)
	return err
}
